/**********************************************************************************************************************
 * \file readdatahandler.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "sidhandler.h"
#include "diagnosticsdata.h"
#include "tof.h"       // tofGetValue 사용
#include "stm.h"
#include "ultrasonic.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
// 0x22: Read Data By Identifier Handler
void handleSID22(const uint8_t* data, uint16_t length, const uint8_t sid) {
    // 세션 체크 (Default 이상 허용)
    if (session_getCurrent() < SESSION_DEFAULT) {
        sendNegativeResponse(sid, UDS_NRC_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION); // 0x7F
        return;
    }

    if (length != 3) {
        sendNegativeResponse(sid, UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
        return;
    }

    uint16_t did = (data[1] << 8) | data[2];
    uint8_t responseMsg[256]; // Sufficient buffer
    uint16_t responseLen = 0;

    responseMsg[responseLen++] = UDS_POSITIVE_RESPONSE_SID(sid);
    responseMsg[responseLen++] = (did >> 8) & 0xFF;
    responseMsg[responseLen++] = did & 0xFF;

    switch (did) {
        case UDS_DID_TOF_SENSOR:
        {
            uint32_t currentTofValue = tofGetValue();
            if (currentTofValue != TOF_INVALID_VALUE) {

                responseMsg[responseLen++] = (currentTofValue >> 16) & 0xFF;
                responseMsg[responseLen++] = (currentTofValue >> 8) & 0xFF;
                responseMsg[responseLen++] = currentTofValue & 0xFF;

                CANTP_SendResponse(responseMsg, responseLen);
            }
            else {
                sendNegativeResponse(sid, UDS_NRC_CONDITIONS_NOT_CORRECT);
            }
            break;
        }

        case UDS_DID_LEFT_ULTRASONIC_SENSOR:
        {
            float distance_cm = ultrasonic_getDistanceCm(ULT_LEFT);
            if (distance_cm < 0)
            {
                sendNegativeResponse(sid, UDS_NRC_CONDITIONS_NOT_CORRECT);
                return;
            }
            uint16_t scaled_distance = (uint16_t) (distance_cm * 10.0f);
            responseMsg[responseLen++] = (scaled_distance >> 8) & 0xFF;
            responseMsg[responseLen++] = scaled_distance & 0xFF;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_RIGHT_ULTRASONIC_SENSOR:
        {
            float distance_cm = ultrasonic_getDistanceCm(ULT_RIGHT);
            if (distance_cm < 0)
            {
                sendNegativeResponse(sid, UDS_NRC_CONDITIONS_NOT_CORRECT);
                return;
            }
            uint16_t scaled_distance = (uint16_t) (distance_cm * 10.0f);
            responseMsg[responseLen++] = (scaled_distance >> 8) & 0xFF;
            responseMsg[responseLen++] = scaled_distance & 0xFF;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_REAR_ULTRASONIC_SENSOR:
        {
            float distance_cm = ultrasonic_getDistanceCm(ULT_REAR);
            if (distance_cm < 0)
            {
                sendNegativeResponse(sid, UDS_NRC_CONDITIONS_NOT_CORRECT);
                return;
            }
            uint16_t scaled_distance = (uint16_t) (distance_cm * 10.0f);
            responseMsg[responseLen++] = (scaled_distance >> 8) & 0xFF;
            responseMsg[responseLen++] = scaled_distance & 0xFF;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_ACTIVE_DIAGNOSTIC_SESSION:
        {
            responseMsg[responseLen++] = (uint8_t) session_getCurrent();

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_VEHICLE_MANUFACTURER_ECU_PART_NUMBER:
        {
            size_t len = sizeof(g_config.partNumber);
            memcpy(&responseMsg[responseLen], g_config.partNumber, len);
            responseLen += len;
            // 4. CAN-TP를 통해 최종 응답 메시지를 전송합니다.
            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_ECU_SERIAL_NUMBER:
        {
            size_t len = sizeof(g_config.serialNumber);
            memcpy(&responseMsg[responseLen], g_config.serialNumber, len);
            responseLen += len;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_VEHICLE_IDENTIFICATION_NUMBER:
        {
            size_t len = sizeof(g_config.vin);
            memcpy(&responseMsg[responseLen], g_config.vin, len);
            responseLen += len;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_ECU_SUPPLIER_INFORMATION:
        {
            size_t len = sizeof(g_config.supplier);
            memcpy(&responseMsg[responseLen], g_config.supplier, len);
            responseLen += len;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_ECU_MANUFACTURING_DATE:
        {
            size_t len = sizeof(g_config.manufacturingDate);
            memcpy(&responseMsg[responseLen], g_config.manufacturingDate, len);
            responseLen += len;

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }

        case UDS_DID_SUPPORTED_DIDS_LIST:
        {
            for (int i = 0; i < NUM_SUPPORTED_DIDS; i++) {
                responseMsg[responseLen++] = (uint8_t)(SUPPORTED_DIDS[i] >> 8);
                responseMsg[responseLen++] = (uint8_t)(SUPPORTED_DIDS[i] & 0xFF);
            }

            CANTP_SendResponse(responseMsg, responseLen);
            break;
        }
        default:
            sendNegativeResponse(sid, UDS_NRC_REQUEST_OUT_OF_RANGE);
            break;
    }
}

// 0x2A: Read Data By Periodic Identifier Handler
void handleSID2A(const uint8_t* data, uint16_t length, const uint8_t sid) {
    // 세션 체크 (Default 이상 허용)
    if (session_getCurrent() < SESSION_DEFAULT) {
        sendNegativeResponse(sid, UDS_NRC_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION); // 0x7F
        return;
    }

    if (length < 4) { // subFunction + DID
        sendNegativeResponse(sid, UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
        return;
    }

    uint8_t subFunction = data[1];
    uint16_t requestedDid = (data[2] << 8) | data[3];

    int task_index = -1;
    for (int i = 0; i < MAX_PERIODIC_TASKS; i++) {
        if (g_periodicTasks[i].did == requestedDid) {
            task_index = i;
            break;
        }
    }

    if (task_index != -1) { // 해당 DID를 가진 작업을 찾았다면
        uint8_t payload[4];
        payload[0] = UDS_POSITIVE_RESPONSE_SID(sid);
        payload[1] = subFunction;
        payload[2] = (requestedDid >> 8) & 0xFF;
        payload[3] = requestedDid & 0xFF;

        switch (subFunction) {
            case 0x01: // startSending
                g_periodicTasks[task_index].isActive = 1;
                g_periodicTasks[task_index].timer = g_periodicTasks[task_index].intervalMs;

                CANTP_SendResponse(payload, sizeof(payload));

                if (MODULE_STM0.ICR.B.CMP1EN == 0) {
                    // 다음 인터럽트 시점 설정 (현재 시간 + 주기)
                    MODULE_STM0.CMP[1].U = (uint32_t)(MODULE_STM0.TIM0.U + PERIODIC_TICKS);
                    // 인터럽트 플래그 클리어 및 활성화
                    MODULE_STM0.ISCR.B.CMP1IRR = 1U;
                    MODULE_STM0.ICR.B.CMP1EN = 1U;
                }
                break;

            case 0x02: // stopSending
                g_periodicTasks[task_index].isActive = 0;

                CANTP_SendResponse(payload, sizeof(payload));
                break;

            default:
                sendNegativeResponse(sid, UDS_NRC_SUB_FUNCTION_NOT_SUPPORTED);
                break;
        }
    }
    else {
        sendNegativeResponse(sid, UDS_NRC_REQUEST_OUT_OF_RANGE);
    }
}
