/**********************************************************************************************************************
 * \file cantp.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cantp.h"
#include "uds.h" // 재조립 완료 후 UDS 계층 함수를 호출
#include "can.h"
#include <string.h>
#include "util.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define FLOW_CONTROL_SEPARATION_TIME_MS 0x0F // 15ms

/*********************************************************************************************************************/
/*------------------------------------------------Type Definition----------------------------------------------------*/
/*********************************************************************************************************************/
//typedef enum {
//    CANTP_SESSION_STATE_IDLE = 0,
//    CANTP_SESSION_STATE_RECEIVING,
//    CANTP_SESSION_STATE_SENDING
//} CANTP_SessionState;
//
//typedef struct {
//    CANTP_SessionState state;
//    uint16 rxTotalSize;
//    uint8 rxConsecutiveSeqNum;
//    uint8 rxBuffer[CANTP_RX_BUFFER_SIZE];
//    uint16 rxBufferCounter;
//    uint8_t rxBlockFrameCount;
//
//    uint16 txTotalSize;
//    uint16 txBufferCounter;
//    uint8 *txBuffer;
//    uint8 txConsecutiveSeqNum;
//} CANTP_Session;

//typedef enum {
//    CANTP_FRAME_TYPE_SINGLE_FRAME = 0x0,
//    CANTP_FRAME_TYPE_FIRST_FRAME = 0x1,
//    CANTP_FRAME_TYPE_CONSECUTIVE_FRAME = 0x2,
//    CANTP_FRAME_TYPE_FLOW_CONTROL = 0x3
//} CANTP_FrameType;

//typedef enum {
//    CANTP_FLOW_STATUS_CONTINUE = 0,
//    CANTP_FLOW_STATUS_WAIT = 1,
//    CANTP_FLOW_STATUS_OVERFLOW = 2
//} CANTP_FlowStatus;

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
// --- 수신(Rx) 상태 관리 변수 ---
static volatile IsoTpState g_iso_tp_rx_state = ISO_TP_STATE_IDLE;
static volatile uint16_t g_uds_rx_total_size = 0;
static volatile uint8_t g_rx_expected_seq_num = 0;
static volatile uint8_t g_uds_rx_buffer[CANTP_RX_BUFFER_SIZE];
static volatile uint16_t g_uds_rx_received_size = 0;
static volatile uint16_t g_rx_block_frame_count = 0;

// --- 송신(Tx) 상태 관리 변수 ---
static volatile IsoTpState g_iso_tp_tx_state = ISO_TP_STATE_IDLE;
static volatile uint8_t g_uds_tx_buffer[CANTP_TX_BUFFER_SIZE];
static volatile uint16_t g_uds_tx_total_size = 0;
static volatile uint16_t g_uds_tx_sent_size = 0;
static volatile uint8_t g_tx_seq_num = 0;
static volatile uint8_t g_tx_block_size = 0;   // FC 프레임에서 받은 Block Size (0이면 모든 프레임 전송)
static volatile uint16_t g_tx_stmin_ms = 10;     // FC 프레임에서 받은 STmin [ms]

static volatile uint8_t g_rx_frame_flag = 0; // rx ISR 플래그
static uint8_t g_rx_frame_data[8];
static unsigned int g_rx_frame_id = 0;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void handleSingleFrame(const unsigned char* can_data);
void handleFirstFrame(const unsigned char* can_data);
void handleConsecutiveFrame(const unsigned char* can_data);
void handleFlowControl(const unsigned char* can_data);

void sendSingleFrame(const uint8_t* data, uint16_t length);
void sendFirstFrame(const uint8_t* data, uint16_t length);
void sendConsecutiveFrame(void);
void sendFlowControl(uint8_t flowStatus, uint8_t blockSize, uint8_t separationTime);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void CANTP_HandleRxISR(const unsigned char* canData, unsigned int canId) {
    if (g_rx_frame_flag == 0) {
        memcpy(g_rx_frame_data, canData, 8);
        g_rx_frame_id = canId;
        g_rx_frame_flag = 1; // 메인 루프가 처리하도록 플래그 설정
    }
}

void CANTP_MainFunction(void) {
    if (g_rx_frame_flag == 1) {
        uint8_t canData[8];
        unsigned int canID;

        memcpy(canData, g_rx_frame_data, 8);
        canID = g_rx_frame_id;
        g_rx_frame_flag = 0; // 플래그 즉시 초기화

        if (canID == UDS_REQUEST_CAN_ID) {
            uint8_t pciType = (canData[0] & 0xF0) >> 4;

            switch (pciType) {
                case 0: // Single Frame (SF)
                    handleSingleFrame(canData);
                    break;
                case 1: // First Frame (FF)
                    handleFirstFrame(canData);
                    break;
                case 2: // Consecutive Frame (CF)
                    handleConsecutiveFrame(canData);
                    break;
                case 3: // flow control Frame (FC)
                    handleFlowControl(canData);
                    break;
            }
        }
    }
}

// UDS 응답 전송 시작 함수
void CANTP_SendResponse(const uint8_t* data, uint16_t length) {
    if (g_iso_tp_tx_state != ISO_TP_STATE_IDLE) return; // 전송 중이면 무시

    if (length <= 7) { // Single Frame
        sendSingleFrame(data, length);

    }
    else { // First Frame
        sendFirstFrame(data, length);
    }
}

void handleSingleFrame(const unsigned char* canData) {
    if (g_iso_tp_rx_state == ISO_TP_STATE_IDLE) {
        uint8_t msg_len = canData[0] & 0x0F;
        UDS_HandleMessage(&canData[1], msg_len);
    }
}

void handleFirstFrame(const unsigned char* canData) {
    if (g_iso_tp_rx_state == ISO_TP_STATE_IDLE) {
        memset((void*)g_uds_rx_buffer, 0, CANTP_RX_BUFFER_SIZE);

        g_uds_rx_total_size = ((canData[0] & 0x0F) << 8) | canData[1];
        memcpy((void*)g_uds_rx_buffer, &canData[2], 6);
        g_uds_rx_received_size = 6;
        g_rx_expected_seq_num = 1;

        g_rx_block_frame_count = 0;
        g_iso_tp_rx_state = ISO_TP_STATE_WAIT_CF;

        sendFlowControl(0, FLOW_CONTROL_BLOCK_SIZE, FLOW_CONTROL_SEPARATION_TIME_MS);
    }
}

void handleConsecutiveFrame(const unsigned char* canData) {
    if (g_iso_tp_rx_state != ISO_TP_STATE_WAIT_CF) return;

    uint8_t sequenceNumber = canData[0] & 0x0F;
    if (sequenceNumber == g_rx_expected_seq_num) {
        uint16_t remainingBytes = g_uds_rx_total_size - g_uds_rx_received_size;
        uint8_t bytesToCopy = (remainingBytes > 7) ? 7 : remainingBytes;

        memcpy(&g_uds_rx_buffer[g_uds_rx_received_size], &canData[1], bytesToCopy);

        g_uds_rx_received_size += bytesToCopy;
        g_rx_expected_seq_num = (g_rx_expected_seq_num + 1) % 16; // 15 다음에는 0으로 돌아감

        g_rx_block_frame_count++;

        if (g_uds_rx_received_size >= g_uds_rx_total_size) { // 모든 데이터 조각을 다 받았는지 확인
            UDS_HandleMessage((uint8_t*)g_uds_rx_buffer, g_uds_rx_total_size);
            g_iso_tp_rx_state = ISO_TP_STATE_IDLE;
        }
        else if (FLOW_CONTROL_BLOCK_SIZE > 0 && g_rx_block_frame_count == FLOW_CONTROL_BLOCK_SIZE) {
            // Block Size만큼 프레임을 다 받고, 아직 받을 데이터 남을 경우
            g_rx_block_frame_count = 0;
            sendFlowControl(0, FLOW_CONTROL_BLOCK_SIZE, FLOW_CONTROL_SEPARATION_TIME_MS);
        }
    }
    else { // consecutive frame error
        g_iso_tp_rx_state = ISO_TP_STATE_IDLE;
    }
}

void handleFlowControl (const unsigned char *canData) {
    if (g_iso_tp_tx_state == ISO_TP_STATE_WAIT_FC) {
        uint8_t flowStatus = canData[0] & 0x0F;
        if (flowStatus == 0) { // Continue To Send (CTS)
            g_iso_tp_tx_state = ISO_TP_STATE_SENDING_CF;
            g_tx_block_size = canData[1];

            uint8_t stmin = canData[2];
            if (stmin <= 0x7F) {
                g_tx_stmin_ms = (uint16_t) stmin;
            }
            else if (stmin >= 0xF1 && stmin <= 0xF9) {
                g_tx_stmin_ms = 1;
            }

            sendConsecutiveFrame();
        }
        else if (flowStatus == 1) { // wait

        }
        else { // overflow
            g_iso_tp_tx_state = ISO_TP_STATE_IDLE;
        }
    }
}


void sendSingleFrame(const uint8_t* data, uint16_t length) {
    uint8_t sfFrame[8] = {0,};
    sfFrame[0] = 0x00 | length; // PCI 생성
    memcpy(&sfFrame[1], data, length); // 실제 데이터 복사

    canSendMsg(UDS_RESPONSE_CAN_ID, sfFrame, 8);
}

void sendFirstFrame(const uint8_t* data, uint16_t length) {
    memset((void*)g_uds_tx_buffer, 0, CANTP_TX_BUFFER_SIZE);

    memcpy((void*)g_uds_tx_buffer, data, length);
    g_uds_tx_total_size = length;
    g_uds_tx_sent_size = 6;
    g_tx_seq_num = 1;

    uint8_t ffFrame[8] = {0,};
    ffFrame[0] = 0x10 | ((length >> 8) & 0x0F);
    ffFrame[1] = length & 0xFF;
    memcpy(&ffFrame[2], data, 6);

    canSendMsg(UDS_RESPONSE_CAN_ID, ffFrame, 8); // 첫 프레임 전송 시작
    g_iso_tp_tx_state = ISO_TP_STATE_WAIT_FC;
}

void sendConsecutiveFrame(void) {
    if (g_iso_tp_tx_state == ISO_TP_STATE_SENDING_CF) {
        uint8_t block_count = 0; // 이번 블록에서 보낸 프레임 카운트

        while (g_uds_tx_sent_size < g_uds_tx_total_size) { // 모든 데이터가 전송될 때까지
            if (g_tx_block_size > 0 && block_count >= g_tx_block_size) {
                g_iso_tp_tx_state = ISO_TP_STATE_WAIT_FC; // 다음 FC 대기 상태로 전환
                return;
            }

            uint8_t cfFrame[8] = {0,};
            cfFrame[0] = 0x20 | (g_tx_seq_num & 0x0F);

            uint16_t remainingSize = g_uds_tx_total_size - g_uds_tx_sent_size;
            uint8_t bytesToSend = (remainingSize > 7) ? 7 : remainingSize;

            memcpy(&cfFrame[1], (void*)&g_uds_tx_buffer[g_uds_tx_sent_size], bytesToSend);

            canSendMsg(UDS_RESPONSE_CAN_ID, (const char*)cfFrame, bytesToSend + 1);

            g_uds_tx_sent_size += bytesToSend;
            g_tx_seq_num = (g_tx_seq_num + 1) % 16;
            block_count++; // 이번 블록에서 보낸 프레임 수 증가

            // 보낼 데이터가 더 남아있다면, STmin 만큼 대기
            if (g_uds_tx_sent_size < g_uds_tx_total_size) {
                if (g_tx_stmin_ms > 0) {
                    delayMs(g_tx_stmin_ms);
                }
            }
        }
        // 모든 데이터 전송 완료
        g_iso_tp_tx_state = ISO_TP_STATE_IDLE;
    }
}

void sendFlowControl(uint8_t flowStatus, uint8_t blockSize, uint8_t separationTime) {
    uint8_t fcFrame[8] = {0, };
    fcFrame[0] = 0x30 | (flowStatus & 0x0F); // PCI 생성
    fcFrame[1] = blockSize;
    fcFrame[2] = separationTime; //STmin

    canSendMsg(UDS_RESPONSE_CAN_ID, fcFrame, 8);
}
